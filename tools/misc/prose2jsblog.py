import re
from pathlib import Path
from typing import Union

from tools.build_system.typing import PathString, StringList

INDENT = " " * 4


def get_blog_source_text(in_path: Union[str, Path]):
    with open(in_path) as text_file:
        raw_content = text_file.read()

    raw_content = [line for line in raw_content.split("\n")]
    if raw_content[-1] != "":
        raw_content.append("")

    return raw_content


def apply_bold_italic(line: str):
    retval = line
    if line.count("*") >= 2:
        bold_replace_indices = []
        italic_replace_indices = []

        for i, ch in enumerate(line):
            if i == len(line) - 1:
                break

            if ch == "*":
                if line[i + 1] == "*":
                    bold_replace_indices.append(i)
                else:
                    italic_replace_indices.append(i)

        assert (
            len(bold_replace_indices) % 2 == 0 and len(italic_replace_indices) % 2 == 0
        ), f"Mismatch in bold or italic statement: {line}"

        for i, str_idx in enumerate(bold_replace_indices):
            if i % 2 == 0:
                repl = "<b>"
            else:
                repl = "</b>"

            retval = retval[:str_idx] + repl + line[str_idx + 1 : -1]

        for i, str_idx in enumerate(italic_replace_indices):
            if i % 2 == 0:
                repl = "<i>"
            else:
                repl = "</i>"
            retval = retval[:str_idx] + repl + line[str_idx + 1 : -1]

    return retval


def parse_raw_source_text(raw_content: StringList):
    header_pattern = "^# .* #$"
    date_pattern = "^## 20\d\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01]) ##$"

    content_lines = []
    append_text = ""
    prepend_text = ""
    content_flag = False

    for line_num, line in enumerate(raw_content):
        if line_num == len(raw_content) - 1:
            break

        header = re.match(header_pattern, line)
        date = re.match(date_pattern, line)

        content_begin = line == "###"
        content_end = line == "####"

        paragraph_begin = (
            raw_content[line_num - 1] == ""
            or raw_content[line_num - 1] == content_begin
        )
        paragraph_end = (
            raw_content[line_num + 1] == "" or raw_content[line_num + 1] == content_end
        )

        if header:
            line_stripped = line.strip("# ")
            content_lines.append(f"<h2>{line_stripped}</h2>")
            continue
        elif date:
            line_stripped = line.strip("#").strip(" ")
            content_lines.append(f"<i>{line_stripped}</i>")
            continue
        elif content_begin:
            content_flag = True
            prepend_text = "<p>"
            continue
        elif content_end:
            content_lines.append("<br>\n")
            content_flag = False
            continue
        elif paragraph_begin:
            prepend_text = "<p>"
        elif paragraph_end:
            append_text = "</p>"

        if content_flag:
            line_bold_italic = apply_bold_italic(line)
            content_lines.append(prepend_text + line_bold_italic + append_text)

        prepend_text = ""
        append_text = ""

    return content_lines


def write_js_file(out_path: PathString, content: StringList):
    with open(out_path, "w") as js_file:
        js_file.write("// Autogenerated by prose2jsblog.py, do not edit.\n\n")
        js_file.write("document.write(`\n")
        js_file.write(f'{INDENT}<div class="centeredContent" id="content_blog">\n')
        for line in content:
            js_file.write(f"{INDENT*2}" + line + "\n")
        js_file.write(f"{INDENT}</div>\n`);\n")


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--input", "-i", "Absolute path for the input txt file.", required=True
    )
    parser.add_argument(
        "--output", "-o", "Absolute path for the output javascript file.", required=True
    )
    args = parser.parse_args()

    raw_content = get_blog_source_text(parser.input)
    html_formatted_content = parse_raw_source_text(raw_content)
    write_js_file(parser.output, html_formatted_content)
